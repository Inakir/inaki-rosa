<!DOCTYPE html>
<html>
<head>
    <title>Project Blizzard</title>
    <meta charset="utf-8">
    <style>
        * {
            margin: 0;
            padding: 0
        }

        body {
            overflow: hidden;
        }
    </style>
    <!-- Bootstrap -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

</head>
<body>

<audio autoplay loop>
    <source src="../audio/dark_cell_free_audio.mp3" type="audio/mpeg">
</audio>
<script src="../js/three.min.js"></script>
<script src="../js/threex.planets.js"></script>
<script src="../js/cannon.js"></script>


<script src="../js/stats.min.js"></script>
<script src="three.js-master%20files/js/controls/OrbitControls.js"></script>
<script>

    var showStartScreen = true; // should the start screen be displayed?
    var paused = false; // press p to toggle

    var debug = true; // debug mode; currently just decides whether or not to display fps stats

    var world, timeStep = 10 / 60, camera, scene, renderer, stats, statsContainer, light, SimulationInformation,ambLight;


    var t = 0; //time, used for time dependent events, such as the moon exploding
    var explosionTime = 3; //time that the moon explodes. explosion lasts for 5 seconds

    //izzy variables
    var izzyPhys, izzyMesh;
    var izzyScale = 1/3;
    var izzySize = 1.5;
    var izzyMass = 1;
    var izzyAngularVelocity = .01; //same ask arkAngularVelocity
    var izzyDistance = 20;
    var izzyVelocity = izzyDistance * izzyAngularVelocity;
    var izzyDegreesAheadOfArklets = 20;

    //dodging
    var watchMeteors=[];
    var IZZYCircle;
    var watchDistance= 10;
    var hitounter=0;
    var isIZZYalive = true;

    //ark variables
    var arkPhys = [];
    var arkMesh = [];
    var arkScale = .3;
    var arkSize = .05;
    var arkMass = .1;
    var arkVelocity = .5;
    var arkDistance = 3;
    var arkAngularVelocity = .01; //using this so they all orbit at same angular velocity regardless of distance
    var arkletcount = 25;
    var numberOfPeopleLeft = arkletcount* 5 + 188; //arklets contain 5 souls per and IZZY contains 188 souls
    //moon variables
    var moonPhys, moonMesh, halfMoonMesh;
    var moonSize = 4;
    var moonMass = 150; //assuming density of 1
    var moonVelocity = 1;
    var moonDistance = 40;

    //moon explosion
    var moonExplosionMesh;
    var moonExplosionSize=.5;

    //moon fragments
    var moonFrag = [];

    var meteorPhys = [];
    var meteorMesh = [];
    var meteorScale = 2;
    var meteorSize =1.5;
    var meteorMass = 1;
    var meteorVelocity = 2.5;
    var meteorDistance = 50;
    var meteorCount = 0;
    var addMeteor = true;
    var meteorType = true;
    //earth variables
    var earthPhys, earthMesh, cloudMesh;
    var earthSize = 10;

    //setup camera controls
    var controls;

    // start screen vars
    var rotateClockwise = false;

    // clickable objects
    var raycaster;
    var mouse; // 2d vector representing mouse coords
    var clickableMeshes = []; // meshes in this array can respond to user clicks
    var clickedMesh = null;

    // initialize engine vars
    initThree();
    initCannon();

    // initialize models
    initStars();
    initEarth();
    initMoon();
    initIZZY();
    initArklets();

    // start simulation
    animate();

    document.addEventListener( 'mousedown', onDocumentMouseDown ); // mouse click listener

    document.addEventListener('keypress',onKeyPress );

    if(showStartScreen) {
        displayStartScreen();
    } else {
        controls = new THREE.OrbitControls(camera, renderer.domElement); // give the user control of the camera
        controls.maxDistance = 200;
        //if you have a minDistance, it stops you from zooming in when you are trying to look
        //at the arklets
    }

    function initCannon() {
        world = new CANNON.World();
        world.gravity.set(0, 0, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;
    }

    function initThree() {
        //the following is based on what I (wesley) learned in csce 441 Graphics
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 50; //initial camera position
        scene.add(camera);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        light = new THREE.DirectionalLight(0xffffff, 1); //simulate sun rays
        light.position.set(50, 50, 50);
        scene.add(light);

        amb = new THREE.AmbientLight(0xffffff, .5); //ambient light for more aesthetic rendering
        scene.add(amb);

        //clickableObjs.push(earthMesh);

        //moon fireball
        var moonExplosionGeo = new THREE.SphereGeometry(moonSize, 32, 32);
        var moonExplosionMat = new THREE.MeshPhongMaterial();
        moonExplosionMat.map = THREE.ImageUtils.loadTexture('../images/explosionGIF.gif');
        moonExplosionMesh = new THREE.Mesh(moonExplosionGeo, moonExplosionMat);
        moonExplosionMesh.position.x = 500000;//place this off the screen at first
        moonExplosionMesh.scale.set(moonExplosionSize, moonExplosionSize, moonExplosionSize);
        scene.add(moonExplosionMesh);

        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        SimulationInformation = document.createElement('info');
        document.body.appendChild(SimulationInformation);


        if(debug) { // put helpful debug stuff here
            // displays current fps
            statsContainer = document.createElement('div'); // container to display three.js stats
            document.body.appendChild(statsContainer);

            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';

            statsContainer.appendChild(stats.domElement);
            statsContainer.appendChild(renderer.domElement);
        }
        window.addEventListener( 'resize', onWindowResize, false );
    }

    function initStars(){
        //these stars are actually just a sphere with the 'inside' given a texture of stars/planets/sun
        // create the geometry sphere
        var star_geo = new THREE.SphereGeometry(200, 32, 32);

        // create the material, using a texture of startfield
        var star_mat = new THREE.MeshBasicMaterial();
        star_mat.map = THREE.ImageUtils.loadTexture('../images/galaxy_starfield.png');
        star_mat.side = THREE.BackSide;
        star_mat.ambient = 20;

        // create the mesh based on star_geo and star_mat
        var m = new THREE.Mesh(star_geo, star_mat);
        scene.add(m);
    }

    function initEarth(){
        //create earth physics and graphics
        var earthShape = new CANNON.Sphere(earthSize);
        earthPhys = new CANNON.Body({mass: 0});
        earthPhys.addShape(earthShape);
        earthPhys.angularVelocity.set(10,0,0);
        world.addBody(earthPhys);

        //create Earth three mesh
        var earth_geo = new THREE.SphereGeometry(earthSize, 32, 32);

        var earth_mat = new THREE.MeshPhongMaterial();
        earthMesh = new THREE.Mesh(earth_geo, earth_mat);


        earth_mat.map = THREE.ImageUtils.loadTexture('../images/earthmap1k.jpg');
        earth_mat.bumpMap = THREE.ImageUtils.loadTexture('../images/earthbump1k.jpg');
        earth_mat.bumpScale = 3;
        earth_mat.needsUpdate = true;
        earth_mat.map.needsUpdate = true;

        cloudMesh =  THREEx.Planets.createEarthCloud();
        cloudMesh.scale.set(1.99*earthSize, 1.99*earthSize, 1.99*earthSize);
        scene.add(cloudMesh);
        scene.add(earthMesh);
    }

    function initMoon(){
        //create moon physics and graphics
        var moonShape = new CANNON.Sphere(moonSize);

        moonPhys = new CANNON.Body({
            mass: moonMass,
            position: new CANNON.Vec3(moonDistance, 0, 0)
        });
        moonPhys.linearDamping = 0.0;
        moonPhys.addShape(moonShape);
        moonPhys.velocity.set(0, 0, moonVelocity);

        world.addBody(moonPhys);

        //           Use the preStep callback to apply the gravity force on the moon.
//           This callback is evoked each time step.
        moonPhys.preStep = function () {

            // Get the vector pointing from the moon to the planetPhys center
            var moon_to_earth = new CANNON.Vec3();
            this.position.negate(moon_to_earth);

            // Get distance from planet to moon
            var distance = moon_to_earth.norm();

            // Now apply force on moon
            // Fore is pointing in the moon-planet direction
            moon_to_earth.normalize();

            //this is centripetal force formula, F=mass*velocity^2 / radius. credit: BK
            moon_to_earth.mult(moonMass*Math.pow(moonVelocity,2) / distance, this.force);

        };
        //moon
        moonMesh = new THREEx.Planets.createMoon();
        moonMesh.scale.set(moonSize, moonSize, moonSize);
        scene.add(moonMesh);

        loader = new THREE.JSONLoader();
        loader.load('../models/halfmoon.json', function (geometry, materials)
        {
            var halfMoonMat = new THREE.MeshPhongMaterial(); // base material
            halfMoonMesh = new THREE.Mesh(geometry, halfMoonMat);
            halfMoonMat.map = THREE.ImageUtils.loadTexture('../images/moonbump1k.jpg'); // load texture

            halfMoonMesh.scale.set(moonSize, moonSize, moonSize);
            //halfMoonMesh.receiveShadow = true;
            //halfMoonMesh.castShadow = true;
            //halfMoonMesh.rotation.z = -Math.PI/5;
            halfMoonMesh.position.set(moonPhys.position.x, moonPhys.position.y, moonPhys.position.z);
        });

        clickableMeshes.push(moonMesh);
    }

    function initIZZY() {

        //helps in choosing how far izzy leads the arklets in orbit
        var radiansAheadOfArklets = izzyDegreesAheadOfArklets * (Math.PI /180);

        // IZZY Physics
        var izzyShape = new CANNON.Sphere(izzySize);

        izzyPhys = new CANNON.Body({
            mass: izzyMass,
            position: new CANNON.Vec3(Math.cos(radiansAheadOfArklets)*izzyDistance, 0, Math.sin(radiansAheadOfArklets)*izzyDistance)
        });
        izzyPhys.linearDamping = 0.0;
        izzyPhys.addShape(izzyShape);

        //need izzy to start out ahead of the arklets
        izzyPhys.velocity.set(-Math.sin(radiansAheadOfArklets)*izzyVelocity, 0, Math.cos(radiansAheadOfArklets)*izzyVelocity);

        world.addBody(izzyPhys);

        izzyPhys.preStep = function () {

            // Get the vector pointing from the moon to the planetPhys center
            var izzy_to_earth = new CANNON.Vec3();
            this.position.negate(izzy_to_earth);

            // Get distance from planet to moon
            var distance = izzy_to_earth.norm();

            // Now apply force on moon, force is pointing in the moon-planet direction
            izzy_to_earth.normalize();

            //this is centripetal force formula, F=mass*velocity^2 / radius. credit: BK
            izzy_to_earth.mult(izzyMass*Math.pow(izzyVelocity,2) / distance, this.force);

        };

        // IZZY Mesh
        loader = new THREE.JSONLoader(); // JSON 3D Model loader
        // load model TODO: this is executed on a diff thread. Might need to delay rendering until these are done loading.
        loader.load('../models/issTest5.json', function (geometry, materials) {
            var izzyMat = new THREE.MeshPhongMaterial(); // base material

            izzyMesh = new THREE.Mesh(geometry, izzyMat); // create mesh

            izzyMat.map = THREE.ImageUtils.loadTexture('../images/izzy_texture2.png'); // load texture

            izzyMesh.scale.set(izzyScale, izzyScale, izzyScale);
            //izzyMesh.receiveShadow = true;
            //izzyMesh.castShadow = true;
            //izzyMesh.rotation.z = -Math.PI/5;

            scene.add(izzyMesh); // render izzy
            clickableMeshes.push(izzyMesh);
        });

    }

    function initArklets() {
        for(var i = 0; i < arkletcount; i++) {
            //ark physics
            var arkShape = new CANNON.Sphere(arkSize);

            var tempArkPhys;
            var tempArkMesh;


            //placement of the Arklets
            //start in 3d circular fashion
            var degree = Math.random()*Math.PI*2;
            var degree2 = Math.random()*Math.PI*2;
            var xpos = Math.sin(degree)*(arkDistance) + (.5*arkDistance);
            var ypos = Math.cos(degree2)*(arkDistance) + (.5*arkDistance);
            var zpos = Math.cos(degree)*(arkDistance) + (.5*arkDistance);

            var pos = new CANNON.Vec3(izzyDistance + xpos, ypos,  zpos);
            tempArkPhys = new CANNON.Body({
                position: pos,
                mass: arkMass //pos.length() / (arkVelocity*arkVelocity)
                //position : new CANNON.Vec3(Math.random()*3+16,Math.random()*2,Math.random()*2)
            });
            tempArkPhys.linearDamping = 0.0;
            tempArkPhys.addShape(arkShape);

            tempArkPhys.velocity.set(0, 0, arkAngularVelocity*tempArkPhys.position.length());

            world.addBody(tempArkPhys);

            tempArkPhys.preStep = function () {

                // Get the vector pointing from the moon to the planetPhys center
                var ark_to_earth = new CANNON.Vec3();
                this.position.negate(ark_to_earth);

                // Get distance from planet to moon
                var distance = ark_to_earth.length();

                // Now apply force on moon, force is pointing in the moon-planet direction
                ark_to_earth.normalize();

//                console.log(i," This.mass = ", this.mass, " while arkletMass = ", arkMass);
                //this is centripetal force formula, F=mass*velocity^2 / radius. credit: BK
                //this specific formula (for arklets) is modified to use angular velocity
                ark_to_earth.mult(this.mass * Math.pow(arkAngularVelocity, 2) * distance, this.force);

            };
            arkPhys.push(tempArkPhys);

            //Arklet Mesh
            var arklet_geo = new THREE.MeshPhongMaterial();

            loader.load('../models/arklet.json', function (geometry, materials) {
                var arkMat = new THREE.MeshPhongMaterial();

                tempArkMesh = new THREE.Mesh(geometry, arkMat);

                arkMat.map = THREE.ImageUtils.loadTexture('../images/ark_texture.png');

                tempArkMesh.receiveShadow = true;
                tempArkMesh.castShadow = true;
                tempArkMesh.scale.set(arkScale, arkScale, arkScale);
                tempArkMesh.position.set(izzyPhys.position.x + xpos, izzyPhys.position.y + ypos,izzyPhys.position.z + zpos);
                arkMesh.push(tempArkMesh);
                scene.add(tempArkMesh);
                clickableMeshes.push(tempArkMesh);
            });
        }
    }

    function generateOrthogonalVector(AVec){
        //orthogonal vector is one such that A dot B = 0.
        //the input vector is A.
        //we will randomly choose x and y of B, the output vector.
        //we will compute z of B s.t. A dot B = 0.
        Ax = AVec.x;
        Ay = AVec.y;
        Az = AVec.z;
        var Bx = Math.random()*4+1;
        var By = Math.random()*4+1;
        var Bz = -(Ax * Bx) - (Ay * By);
        Bz = Bz / Az; //now we have Bz
//        console.log("Ax, Ay, Az = ", Ax, Ay, Az, " Bx, By, Bz = ", Bx, By, Bz);
        var vec = new CANNON.Vec3(Bx, By, Bz);
        return vec;

    }

    function initMeteor() {
        // if (t > explosionTime) {
        // meteor Physics
        var meteorShape = new CANNON.Sphere(meteorSize);

        var tempMeteorPhys;
        var tempMeteorMesh;

        tempMeteorPhys= new CANNON.Body({
            mass: meteorMass,
            position: new CANNON.Vec3(moonPhys.position.x, moonPhys.position.y, moonPhys.position.z)
        });
        tempMeteorPhys.linearDamping = 0.0;
        tempMeteorPhys.addShape(meteorShape);
//      need the velocity to be tangent so that it will orbit, rather than just go straight
        //into the earth or away from the earth
        var velocityVec = generateOrthogonalVector(tempMeteorPhys.position);
        velocityVec.normalize();
        velocityVec.scale(-meteorVelocity, tempMeteorPhys.velocity);
//        console.log(tempMeteorPhys.velocity);

        world.addBody(tempMeteorPhys);

        tempMeteorPhys.preStep = function ()
        {
            // Get the vector pointing from the moon to the planetPhys center
            var meteor_to_earth = new CANNON.Vec3();
            this.position.negate(meteor_to_earth);

            // Get distance from planet to moon
            var distance = meteor_to_earth.norm();

            // Now apply force on moon, force is pointing in the moon-planet direction
            meteor_to_earth.normalize();

            //this is centripetal force formula, F=mass*velocity^2 / radius. credit: BK
            meteor_to_earth.mult(meteorMass * Math.pow(meteorVelocity, 2) / distance, this.force);
        };
        meteorPhys.collisionResponse = 0; // no impact on other bodys
        meteorPhys.push(tempMeteorPhys);

        //json file for moon fragment
        loader = new THREE.JSONLoader();

        loader.load('../models/meteor.json', function (geometry, materials)
        {
            var meteorMat = new THREE.MeshPhongMaterial(); // base material

            tempMeteorMesh = new THREE.Mesh(geometry, meteorMat); // create mesh
            meteorMat.map = THREE.ImageUtils.loadTexture('../images/meteor_texture.png'); // load texture

            tempMeteorMesh.scale.set(meteorScale, meteorScale, meteorScale);
            //tempMeteorMesh.receiveShadow = true;
            //tempMeteorMesh.castShadow = true;
            //tempMeteorMesh.rotation.z = -Math.PI/5;
            tempMeteorMesh.position.set(moonPhys.position.x, moonPhys.position.y, moonPhys.position.z);
            meteorMesh.push(tempMeteorMesh);
            scene.add(tempMeteorMesh); // render meteor
            clickableMeshes.push(tempMeteorMesh);
        });
        meteorCount++;
    }

    function newMeteor() {
        // if (t > explosionTime) {
        // meteor Physics
        var meteorShape = new CANNON.Sphere(meteorSize);

        var tempMeteorPhys;
        var tempMeteorMesh;

        // spawn new meteor on a random side of the hit meteor
        var randomAxis = Math.floor((Math.random() * 3) + 1); // random number [1,3]; [x, y,or z]
        var positiveOrNegative = Math.floor((Math.random() * 2) + 1); // random number [1,2]; if 1 -> pos, 2 -> neg
        var meteorPos;
        var offset;

        if(positiveOrNegative == 1){ // the offset is positive
            offset =  meteorSize * 2; // offset by the meteor's diameter
        } else { // the offset is negative
            offset = meteorSize * -2;
        }

        if( randomAxis == 1 ) // add offset to x
            meteorPos =  new CANNON.Vec3(meteorPhys[meteorCount-1].position.x + offset, meteorPhys[meteorCount-1].position.y, meteorPhys[meteorCount-1].position.z);
        else if (randomAxis == 2) // to y
            meteorPos =  new CANNON.Vec3(meteorPhys[meteorCount-1].position.x, meteorPhys[meteorCount-1].position.y + offset, meteorPhys[meteorCount-1].position.z);
        else // to z
            meteorPos =  new CANNON.Vec3(meteorPhys[meteorCount-1].position.x, meteorPhys[meteorCount-1].position.y, meteorPhys[meteorCount-1].position.z + offset);

        tempMeteorPhys= new CANNON.Body({
            mass: meteorMass,
            position: meteorPos
        });

        tempMeteorPhys.linearDamping = 0.0;
        tempMeteorPhys.addShape(meteorShape);

        //need the velocity to be tangent so that it will orbit!
        var velocityVec = generateOrthogonalVector(tempMeteorPhys.position);
        velocityVec.normalize();
        velocityVec.scale(meteorVelocity, tempMeteorPhys.velocity);
//        console.log(tempMeteorPhys.velocity);
        world.addBody(tempMeteorPhys);

        tempMeteorPhys.preStep = function ()
        {
            // Get the vector pointing from the moon to the planetPhys center
            var meteor_to_earth = new CANNON.Vec3();
            this.position.negate(meteor_to_earth);

            // Get distance from planet to moon
            var distance = meteor_to_earth.norm();

            // Now apply force on moon, force is pointing in the moon-planet direction
            meteor_to_earth.normalize();

            //this is centripetal force formula, F=mass*velocity^2 / radius. credit: BK
            meteor_to_earth.mult(meteorMass * Math.pow(meteorVelocity, 2) / distance, this.force);
        };
        meteorPhys.push(tempMeteorPhys);

        //json file for moon fragment
        loader = new THREE.JSONLoader();
        var model;
        if(meteorType)
        {
            model = '../models/meteor.json';
        }
        else
        {
            model = '../models/meteor2.json';
        }
        loader.load(model, function (geometry, materials)
        {
            var meteorMat = new THREE.MeshPhongMaterial(); // base material

            tempMeteorMesh = new THREE.Mesh(geometry, meteorMat); // create mesh
            meteorMat.map = THREE.ImageUtils.loadTexture('../images/meteor_texture.png'); // load texture

            tempMeteorMesh.scale.set(meteorScale, meteorScale, meteorScale);
            //tempMeteorMesh.receiveShadow = true;
            //tempMeteorMesh.castShadow = true;
            //tempMeteorMesh.rotation.z = -Math.PI/5;
            tempMeteorMesh.position.set(tempMeteorPhys.position.x, tempMeteorPhys.position.y, tempMeteorPhys.position.z);
            meteorMesh.push(tempMeteorMesh);
            scene.add(tempMeteorMesh); // render meteor
            clickableMeshes.push(tempMeteorMesh);
        });
        meteorCount++;
    }

    function animate() {
        requestAnimationFrame(animate);
        displaySurvivors();
        if(!paused){
            updatePhysics();

            if( showStartScreen && typeof arkMesh[0] !== 'undefined') { // makes the camera follow Izzy while the start screen is up
                cameraFollow(arkMesh[0]);

            }

            if(clickedMesh !== null){ // If a mesh has been clicked
                cameraFollow(clickedMesh);
            }
        }

        render();

        if(debug) { // show debug info
            stats.update(); // updates fps display
        }
    }


    function DistanceFromIzzy(Vec){ //obj 1 = izzy , obj2 = vec
        Math.pow(Vec.x - izzyMesh.position.x,2);
        var objectDistance = Math.sqrt(Math.pow(Vec.x - izzyMesh.position.x,2) +
                Math.pow(Vec.y - izzyMesh.position.y,2) +
                Math.pow(Vec.z - izzyMesh.position.z,2));
//        console.log(objectDistance);
         if(objectDistance< watchDistance/2) return true;
        else return false;
    }

    function updatePhysics() {
        // Step the physics world
        world.step(timeStep);
        if(!showStartScreen)
            t = t + .01*timeStep*6; //increment time, for use in things like when to explode the moon

        //earth update
        earthMesh.position.copy(earthPhys.position);
//        earthMesh.quaternion.copy(earthPhys.quaternion);
        earthMesh.rotation.y += .001; //since there is no need for earth's quaternion data
        cloudMesh.rotation.y += .0017; //rotate clouds

        var moonDistance = Math.sqrt( moonPhys.position.x * moonPhys.position.x + moonPhys.position.y * moonPhys.position.y + moonPhys.position.z * moonPhys.position.z );
        if(moonDistance>75)
        {
            if(moonPhys.position.x > 0) {
                moonPhys.velocity.x -= .1;
            }
            else {
                moonPhys.velocity.x += .1;
            }
            if(moonPhys.position.y > 0) {
                moonPhys.velocity.y -= .1;
            }
            else {
                moonPhys.velocity.y += .1;
            }
            if(moonPhys.position.z > 0) {
                moonPhys.velocity.z -= .1;
            }
            else {
                moonPhys.velocity.z += .1;
            }
        }

        if (t < explosionTime) {
            //moon update
            moonMesh.position.copy(moonPhys.position);
            moonMesh.quaternion.copy(moonPhys.quaternion);
            if (t > 2){
                light.intensity = light.intensity+.2*t;
            }

        }
        else if (t < (explosionTime + 5)) { //while moon is on fire
            //moon update
            scene.remove(moonMesh);
            moonExplosionMesh.position.copy(moonPhys.position);
            moonExplosionMesh.quaternion.copy(moonPhys.quaternion);
            light.intensity = 1;
            light.color.setHex( 0xff6666 );
            amb.color.setHex(0xff6666);

        }
        else { //no moon, just asteroids!
            light.color.setHex(0xffffff);
            amb.color.setHex(0xffffff);
            scene.remove(moonExplosionMesh);
            halfMoonMesh.position.copy(moonPhys.position);
            halfMoonMesh.quaternion.copy(moonPhys.quaternion);
            scene.add(halfMoonMesh);
            clickableMeshes.push(halfMoonMesh);
            if(addMeteor)
            {
                initMeteor();
                addMeteor = false;
            }
            //world.removeBody(moonPhys);
        }
        var mod = t%.1;
        if(!addMeteor && (0.0 < mod && mod < 0.001))
        {
            meteorType = !meteorType;
            newMeteor();
            if(meteorSize>2) {
                meteorMesh[meteorCount - 2].scale.set(meteorScale * .8, meteorScale * .8, meteorScale * .8);
                meteorPhys[meteorCount - 2].radius = (meteorSize * .8);
                meteorPhys[meteorCount - 2].mass = (meteorMass * .8);
                meteorScale = meteorScale * 3 / 5;
                meteorSize = meteorSize * 3 / 5;
            }
        }


        //izzy update
        if(typeof izzyMesh !== 'undefined') { // if izzy has loaded
            var distance = Math.sqrt( izzyMesh.position.x * izzyMesh.position.x + izzyMesh.position.y * izzyMesh.position.y + izzyMesh.position.z * izzyMesh.position.z );
            if(distance>izzyDistance+5)
            {
                if(izzyPhys.position.x > 0) {
                    izzyPhys.velocity.x = -izzyVelocity*izzyVelocity;
                }
                else {
                    izzyPhys.velocity.x = izzyVelocity*izzyVelocity;
                }
                if(izzyPhys.position.y > 0) {
                    izzyPhys.velocity.y = -izzyVelocity*izzyVelocity;
                }
                else {
                    izzyPhys.velocity.y = izzyVelocity*izzyVelocity;
                }
                if(izzyPhys.position.z > 0) {
                    izzyPhys.velocity.z = -izzyVelocity*izzyVelocity;
                }
                else {
                    izzyPhys.velocity.z = izzyVelocity*izzyVelocity;
                }
            }
            else {
                var vel = Math.sqrt( izzyPhys.velocity.x * izzyPhys.velocity.x + izzyPhys.velocity.y * izzyPhys.velocity.y + izzyPhys.velocity.z * izzyPhys.velocity.z );
                if(vel<izzyVelocity*.5)
                {
                    var izangle = Math.atan(izzyPhys.position.z/izzyPhys.position.x);
                    izzyPhys.velocity.x = -Math.sin(izangle)*izzyVelocity;
                    izzyPhys.velocity.z = Math.cos(izangle)*izzyVelocity;
                }

            }

            izzyMesh.position.copy(izzyPhys.position); // move izzy to physics generated location
            izzyMesh.quaternion.copy(izzyPhys.quaternion);

            izzyMesh.rotation.y += 20;
        }

        for(var i = 0; i < meteorCount; i++)
        {
            //meteor update
            if (typeof meteorMesh[i] !== 'undefined') {
                var distance = Math.sqrt( meteorMesh[i].position.x * meteorMesh[i].position.x + meteorMesh[i].position.y * meteorMesh[i].position.y + meteorMesh[i].position.z * meteorMesh[i].position.z );
                if(distance>225)                {
                    if(meteorPhys[i].position.x > 0) {
                        meteorPhys[i].velocity.x = -meteorVelocity*meteorVelocity;
                    }
                    else {
                        meteorPhys[i].velocity.x = meteorVelocity*meteorVelocity;
                    }
                    if(meteorPhys[i].position.y > 0) {
                        meteorPhys[i].velocity.y = -meteorVelocity*meteorVelocity;
                    }
                    else {
                        meteorPhys[i].velocity.y = meteorVelocity*meteorVelocity;
                    }
                    if(meteorPhys[i].position.z > 0) {
                        meteorPhys[i].velocity.z = -meteorVelocity*meteorVelocity;
                    }
                    else {
                        meteorPhys[i].velocity.z = meteorVelocity*meteorVelocity;
                    }
                }
                else {
                    if (meteorPhys[i].velocity.x*meteorPhys[i].velocity.x < 16) {
                        meteorPhys[i].velocity.x = meteorVelocity*meteorVelocity;
                    }
                    if (meteorPhys[i].velocity.y*meteorPhys[i].velocity.y < 16) {
                        meteorPhys[i].velocity.y = meteorVelocity*meteorVelocity;
                    }
                    if (meteorPhys[i].velocity.z*meteorPhys[i].velocity.z < 16) {
                        meteorPhys[i].velocity.z = meteorVelocity*meteorVelocity;
                    }
                }
                //adds in a random element to all meteors so that they are unpredictable
                var degree = Math.random()*Math.PI*2;
                var xvel = Math.sin(degree)*.5;
                var zvel = Math.cos(degree)*.5;

                meteorPhys[i].velocity.x += xvel;
                meteorPhys[i].velocity.z += zvel;

                meteorMesh[i].position.copy(meteorPhys[i].position);
                meteorMesh[i].quaternion.copy(meteorPhys[i].quaternion);

                meteorMesh[i].rotation.y += 20;
                if(meteorMesh[i].position.x < earthMesh.position.x + 30 || meteorMesh[i].position.x > earthMesh.position.x - 30 )
                    if(isIZZYalive)AI(meteorMesh[i]);
            }
        }

        //ark update
        for(var i = 0; i < arkletcount; i++)
        {
            if(typeof arkMesh[i] !== 'undefined') { // if ark has loaded

                arkMesh[i].position.copy(arkPhys[i].position); // move ark to physics generated location
                arkMesh[i].quaternion.copy(arkPhys[i].quaternion);

                if(typeof izzyMesh !== 'undefined') {
                    arkMesh[i].rotation.y += 20;
                    if (arkMesh[i].position.y > (izzyMesh.position.y + watchDistance)) { // a safety net for the arklets
                        pushdown(arkPhys[i]);
                    }
                    if (arkMesh[i].position.y < (izzyMesh.position.y - watchDistance)) { // a safety net for the arklets
                        pushup(arkPhys[i]);
                    }
                }
            }
        }

    }

    // if a meteor is within the a set distance of IZZY the AI will move the arklets up or down depending on the meteor's position
    function AI(meteor){
        if (DistanceFromIzzy(meteor)) {
            for (var i = 0; i < arkMesh.length; i++) {
                if (meteor.position.y > izzyMesh.position.y) {
                    pushdown(arkPhys[i])
                }
                else {
                    pushup(arkPhys[i])
                }
            }
        }
    }

    // pushes the arklet down with a force of -.00005
    function pushup(arkletPhys){
        var forceVector = new THREE.Vector3(0, -.00005, 0);
        // Convert the vector to a CANNON vector, otherwise it does nothing
        var cannonVector = new CANNON.Vec3(forceVector.x, forceVector.y, forceVector.z);
        // Apply the impulse at the center of the body
        arkletPhys.applyImpulse(cannonVector, arkletPhys.position);
    }

    // pushes the arklet up with a force of .00005
    function pushdown(arkletPhys){
        var forceVector = new THREE.Vector3(0, -.00005, 0);
        // Convert the vector to a CANNON vector, otherwise it does nothing
        var cannonVector = new CANNON.Vec3(forceVector.x, forceVector.y, forceVector.z);
        // Apply the impulse at the center of the body
        arkletPhys.applyImpulse(cannonVector, arkletPhys.position);
    }

    // displays general information to the user so the user knows the commands and how many people are left
    //  alive in the simulation
    function displaySurvivors() {
        var PeopleLeft = document.createElement('div');
        PeopleLeft.style.position = 'absolute';
        PeopleLeft.style.width = 100;
        PeopleLeft.style.height = 100;
        PeopleLeft.style.backgroundColor = "black";
        PeopleLeft.style.color = "white";
        PeopleLeft.innerHTML = "p to pause  |  -/= to change speed  |  Current Speed: " + (Math.round(timeStep * 100) / 100) + "  |  Survivors Remaining: "+ numberOfPeopleLeft;
        PeopleLeft.style.top = 0+ 'px';
        PeopleLeft.style.left = 100+ 'px';
        document.body.appendChild(PeopleLeft);
    }

    // determines what the two objects are that are touching in the world returns true if it can determine
    function findit( objectA , worldObject){
        for(var i =0; i< arkPhys.length; i++){
            if(worldObject == arkPhys[i]) {
                objectA.name = "Arklet";
                objectA.index = i;
                return true;
            }
        }
        for(var i =0; i< meteorPhys.length; i++){
            if(worldObject == meteorPhys[i]) {
                objectA.name = "Meteor";
                objectA.index = i;
                return true;
            }
        }
        if(worldObject == izzyPhys) {
            objectA.name = "izzy";
            objectA.index = -1;
            return true;
        }
        if(worldObject == earthPhys) {
            objectA.name = "Earth";
            objectA.index = -1;
            return true;
        }

        return false;
    }
    // performs the appropriate action on object A and removes the correct object from the scene and the world
    // based on what is colliding
    function performMeteorAction(objectA, objectB){
        if(objectA.name == "Arklet"){
            scene.remove(arkMesh[objectA.index]);
            world.remove(arkPhys[objectA.index]);
            arkMesh.splice(objectA.index,1);
            arkPhys.splice(objectA.index,1);
            console.log("removed Arklet: "+objectA.index);
            arkletcount--;
            if (arkletcount % 10 ==0) window.alert(arkletcount +' arklets are left');
            numberOfPeopleLeft -=5;
        }else if(objectA.name == "Earth"){
            scene.remove(meteorMesh[objectB.index]);
            world.remove(meteorPhys[objectB.index]);
            if(!watchMeteors.indexOf(meteorMesh[objectB.index])==-1) {
                var index = watchMeteors.indexof(meteorMesh[i]);
                watchMeteors.splice(index,1);
                console.log("removed a meteor from the watch list");
            }
            meteorMesh.splice(objectB.index,1);
            meteorPhys.splice(objectB.index,1);
            meteorCount--;
            console.log("removed Meteor: "+objectB.index);
        } else if(objectA.name == "izzy"){
            // do something not sure at this point in time
            scene.remove(izzyMesh);
            world.remove(izzyPhys);
            console.log("Removed IZZY");
            numberOfPeopleLeft-=188;
            window.alert('IZZY was destroyed, there are only  '+numberOfPeopleLeft+' people are left in '+numArklets+' arklets');
            isIZZYalive = false;
        }
    }
    // determines what course of action should be taken based on what is colliding and passes the objects to the
    // performMeteorAction function in the correct order
    function collisionDetected(objectA, objectB){
        if(objectA.name == "Meteor" || objectB.name == "Meteor"){
            if(objectA.name == "Meteor" && objectB.name == "Meteor") {
//                console.log("performed no action since both are meteors");

            }
            else if(objectA.name == "Meteor"){
//                console.log("performed a meteor action");
                performMeteorAction(objectB, objectA);

            }
            else if(objectB.name == "Meteor") {
//                console.log("performed a meteor action");
                performMeteorAction(objectA, objectB);
            }
        }
    }

    function render() {
        renderer.render(scene, camera);
        if(world.contacts.length > 0) { // world.contacts list hold the object that are touching at any one point in time
            var objectA = { var :index =0 , war :name = "" }; // general purpose variables to hold data about what is touching
            var objectB = { var :index =0 , war :name = "" }; // general purpose variables to hold data about what is touching
            if (world.contacts.length > 0) { // iterates thought the list and figures out what to do based on what is touching
                for (var i = 0; i < world.contacts.length; i++) {
                    var c = world.contacts[i];
                    if(findit(objectA,c.bi))
                        if(findit(objectB, c.bj)) {
//                                console.log(objectA.name + " index:" + objectA.index + " collided with "
//                                        + objectB.name + " index:" + objectB.index);
                            collisionDetected(objectA, objectB);
                        }
                }
            }
        }
    }

    function cameraFollow( aMesh ){ // positions the camera at aMesh, and pans camera
        if (showStartScreen) { // use special start screen effect
            camera.position.copy(aMesh.position); // keep the camera locked on object
            camera.position.z += 3;

            // auto pan camera left and right
            var yRotation = camera.rotation.y;

            if (yRotation > 0.75)
                rotateClockwise = true;
            else if (yRotation < -0.75)
                rotateClockwise = false;

            if (rotateClockwise)
                camera.rotation.y -= .002;
            else
                camera.rotation.y += .002;
        } else { // otherwise just follow the Mesh
            camera.position.copy(aMesh.position);

            var box = new THREE.Box3().setFromObject( aMesh );
            //console.log( box.min, box.max, box.size() );

            camera.position.z += 4; //TODO: scale camera offset to size of mesh

            camera.lookAt(aMesh.position);
        }
    }

    function onDocumentMouseDown( event ) { // detects click. If a mesh is already selected, this unselects it. Otherwise, if a mesh was clicked it is assigned to 'clickedMesh'
        if( !showStartScreen ) { // if not showing the start screen
            //event.preventDefault();

            if (clickedMesh == null) { // If there is no clicked ("selected") mesh
                mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1; // normalize mouse coordinates to a value between -1 and 1
                mouse.y = -( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                var intersects = raycaster.intersectObjects(clickableMeshes); // use raycaster to detect click

                if (intersects.length > 0) {
                    clickedMesh = intersects[0].object; // the camera automatically follows the clicked object (line
                    camera.rotation.z = 0;
                    camera.rotation.x = 0;
                    camera.rotation.y = 0;

                    cameraFollow( clickedMesh ); // move the camera to the mesh
                }
            } else { // otherwise unselect mesh
                clickedMesh = null;
            }
        }
    }
    var d = 1;
    function onKeyPress ( event ){
        if(event.keyCode){
            console.log("KEY PRESSED: " + event.keyCode);
            switch(event.keyCode){ // switch just so we can add more keys if we need
                case 112: // p key pressed
                    if(paused) {
                        paused = false;
                        var pauseMenuDiv = document.getElementById("pauseMenu"); // find pause menu
                        pauseMenuDiv.parentNode.removeChild(pauseMenuDiv); // remove pause menu
                    } else {
                        paused = true;
                        showPauseScreen();
                    }
                    break;
                case 61: case 187: // = increases speed 187?
                    timeStep += 1/60;
                    break;
                case 45: case 189: // - decreases speed 189?
                    if(timeStep > 1/60)
                        timeStep -= 1/60;
                    break;
                case 100:

                    break;
            }
        }
    }

    function startSimulation(){ // called when the user presses the Start Screen's start button
        showStartScreen = false;

        var startMenuDiv = document.getElementById("startMenu"); // find start menu

        startMenuDiv.parentNode.removeChild(startMenuDiv); // remove start menu

        camera.position.z = 50; // zoom out so simulation can begin

        controls = new THREE.OrbitControls(camera, renderer.domElement); // give the user control of the camera

    }

    function showPauseScreen(){
        var startDiv = document.createElement('div');

        // Setting CSS properties
        startDiv.style.position = 'absolute'; // lets the window float on top of the renderer

        startDiv.style.width = "250px";
        startDiv.style.height = "75px";

        startDiv.style.color = 'black';
        startDiv.style.backgroundColor = 'rgba(256, 256, 256, .5)'; // white at 50% transparency
        startDiv.style.borderStyle = 'solid';

        startDiv.id = 'pauseMenu';

        startDiv.style.top = (window.innerHeight*.90 - 75) + 'px'; // 90% down
        startDiv.style.left = (window.innerWidth/2 - 250/2) + 'px'; // centered horizontally

        // startpage Content
        startDiv.innerHTML = "<body> <center> <h3>Paused</h3> </center>";

        // add pause screen to document
        document.body.appendChild(startDiv);
    }

    function updateSliderVal( num ){ // displays current slider val on start screen
        document.getElementById('arkletInput').textContent = "Number of Arklets: " + num;
    }

    function displayStartScreen(){ // generates html code and displays start screen on top of render
        var startDiv = document.createElement('div');

        // Setting CSS properties
        startDiv.style.position = 'absolute'; // lets the window float on top of the renderer

        startDiv.style.width = "360px";
        startDiv.style.height = "200px";

        startDiv.style.paddingTop = '0px';
        startDiv.style.paddingBottom = '0px';
        startDiv.style.paddingLeft = '27px';
        startDiv.style.paddingRight = '27px';

        startDiv.style.color = 'black';
        startDiv.style.backgroundColor = 'rgba(256, 256, 256, .5)';
        startDiv.style.borderStyle = 'solid';

        startDiv.id = 'startMenu';

        startDiv.style.top = (window.innerHeight/2 - 200/2) + 'px'; // centers the screen vertically
        startDiv.style.left = 100 + 'px';

        // startpage Content
        startDiv.innerHTML =
                "<body> <center>" +
                "<h2>- - - - - Blizzard - - - - -</h2>" +
                "</center> <br/>" +
                "<b>3D Physics Simulator - By Group Avalanche</b>" +//"<div id='arkletInput'> Number of Arklets: 305</div><input type='range' min='1' max='305' id='numArkSlider' value='305' onchange='updateSliderVal(this.value)'>" +
                "<br/><br/><br/> <center>"+
                "<button type='button' onclick='startSimulation();'>Start Simulation</button>" +
                "</center> </body>";

        // add startpage to document
        document.body.appendChild(startDiv);
    }

    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }
</script>
</body>
</html>